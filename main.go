package main

import (
	"flag"
	"fmt"
	"os"
	"strings"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/types/pluginpb"
)

const version = "0.0.1"

func main() {
	showVersion := flag.Bool("version", false, "print the version and exit")
	flag.Parse()
	if *showVersion {
		fmt.Printf("protoc-gen-go-oneof-api-adapter %v\n", version)
		return
	}

	var flags flag.FlagSet
	requestOneofPath := flags.String("request", "Request/body", "The oneof path of request messages attachment at")
	responseOneofPath := flags.String("response", "Response/body", "The oneof path of response messages attachment at")
	options := protogen.Options{
		ParamFunc: flags.Set,
	}

	options.Run(func(gen *protogen.Plugin) error {

		gen.SupportedFeatures = uint64(pluginpb.CodeGeneratorResponse_FEATURE_PROTO3_OPTIONAL)
		for _, f := range gen.Files {
			if !f.Generate {
				continue
			}
			generateAdapterFile(gen, f, *requestOneofPath, *responseOneofPath)
		}
		return nil
	})
}

func println(a ...any) {
	os.Stderr.WriteString(fmt.Sprintln(a...))
}

type OneofPath struct {
	MessageName string
	OneofName   string
}

func parseOneofPath(s string) OneofPath {
	parts := strings.Split(s, "/")
	if len(parts) != 2 {
		panic("invalid path")
	}
	return OneofPath{
		MessageName: parts[0],
		OneofName:   parts[1],
	}
}

type HandlerInfo struct {
	Request, Response, Method string
}

const (
	contextPkg = protogen.GoImportPath("context")
	errPkg     = protogen.GoImportPath("errors")
)

// generateAdapterFile generates a _adapter.pb.go file.
func generateAdapterFile(gen *protogen.Plugin, file *protogen.File, requestOneofPath, responseOneofPath string) *protogen.GeneratedFile {
	requestPath := parseOneofPath(requestOneofPath)
	responsePath := parseOneofPath(responseOneofPath)

	filename := file.GeneratedFilenamePrefix + "_oneof_api_adapter.pb.go"
	g := gen.NewGeneratedFile(filename, file.GoImportPath)
	g.P("// Code generated by github.com/panjiang/protoc-gen-go-oneof-api-adapter. DO NOT EDIT.")
	g.P()
	g.P("package ", file.GoPackageName)
	g.P()
	g.P("// This is a compile-time assertion to import dependent packages.")
	g.P("// ", contextPkg.Ident(""))
	g.P("// ", errPkg.Ident(""))
	g.P()

	var reqOneOf, respOneOf *protogen.Oneof
	for _, msg := range file.Messages {
		msgName := string(msg.Desc.Name())
		if msgName == requestPath.MessageName {
			for _, oneof := range msg.Oneofs {
				if string(oneof.Desc.Name()) == requestPath.OneofName {
					reqOneOf = oneof
				}
			}
		} else if msgName == responsePath.MessageName {
			for _, oneof := range msg.Oneofs {
				if string(oneof.Desc.Name()) == responsePath.OneofName {
					respOneOf = oneof
				}
			}
		}
	}

	tmpl := &AdapterTemplate{
		ServerName:             "ProtoApi",
		PackageName:            "",
		UnionRequestType:       requestPath.MessageName,
		UnionResponseType:      responsePath.MessageName,
		UnionRequestBodyField:  reqOneOf.GoName,
		UnionResponseBodyField: respOneOf.GoName,
	}
	for i := 0; i < reqOneOf.Desc.Fields().Len(); i++ {
		reqBodyFieldDesc := reqOneOf.Desc.Fields().Get(i)
		reqNum := reqBodyFieldDesc.Number()
		reqName := string(reqBodyFieldDesc.Message().Name())
		respBodyFieldDesc := respOneOf.Desc.Fields().ByNumber(reqNum)
		if respBodyFieldDesc == nil {
			panic(fmt.Errorf("not found response message by number: %d", reqNum))
		}
		respName := string(respBodyFieldDesc.Message().Name())

		hf := HandlerFunc{}
		hf.Method = strings.TrimSuffix(reqName, "Request")
		hf.RequestType = reqName
		hf.ResponseType = respName
		hf.RequestOneofField = reqOneOf.Fields[i].GoName
		hf.ResponseOneofField = respOneOf.Fields[i].GoName
		hf.RequestOneofType = requestPath.MessageName + "_" + reqOneOf.Fields[i].GoName
		hf.ResponseOneofType = responsePath.MessageName + "_" + respOneOf.Fields[i].GoName

		tmpl.HandlerFuncList = append(tmpl.HandlerFuncList, hf)
	}
	if os.Getenv("DEBUG") == "1" {
		println(fmt.Sprintf("%+v", tmpl))
	}

	content, err := tmpl.execute()
	if err != nil {
		panic(err)
	}

	g.P(content)
	return g
}
