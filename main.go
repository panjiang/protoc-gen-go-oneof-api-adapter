package main

import (
	"flag"
	"fmt"
	"os"
	"strings"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/types/pluginpb"
)

const version = "0.1"

type FlagVar struct {
	RequestOneofPath  string
	ResponseOneofPath string
	ApiName           string
}

func main() {
	var flagVar FlagVar
	var flags flag.FlagSet
	flags.StringVar(&flagVar.RequestOneofPath, "request", "Request/body", "The oneof path of request messages attachment at")
	flags.StringVar(&flagVar.ResponseOneofPath, "response", "Response/body", "The oneof path of response messages attachment at")
	flags.StringVar(&flagVar.ApiName, "api", "Api", "The API name will used as Prefix of classes")

	showVersion := flag.Bool("version", false, "print the version and exit")
	flag.Parse()

	if *showVersion {
		fmt.Printf("protoc-gen-go-oneof-api-adapter %v\n", version)
		fmt.Println("protoc options `--go-oneof-api-adapter_opt=api=$value1,request=$value2,response=$value3`")
		flags.PrintDefaults()
		return
	}

	options := protogen.Options{
		ParamFunc: flags.Set,
	}

	options.Run(func(gen *protogen.Plugin) error {

		gen.SupportedFeatures = uint64(pluginpb.CodeGeneratorResponse_FEATURE_PROTO3_OPTIONAL)
		found := false
		for _, f := range gen.Files {
			if !f.Generate {
				continue
			}

			if generateAdapterFile(gen, f, flagVar) {
				found = true
				break
			}
		}
		if !found {
			panic(fmt.Errorf("not found the path, request: %s, response: %s", flagVar.RequestOneofPath, flagVar.ResponseOneofPath))
		}
		return nil
	})
}

func println(a ...any) {
	os.Stderr.WriteString(fmt.Sprintln(a...))
}

type OneofPath struct {
	MessageName string
	OneofName   string
}

func parseOneofPath(s string) OneofPath {
	parts := strings.Split(s, "/")
	if len(parts) != 2 {
		panic("invalid path")
	}
	return OneofPath{
		MessageName: parts[0],
		OneofName:   parts[1],
	}
}

type HandlerInfo struct {
	Request, Response, Method string
}

const (
	contextPkg = protogen.GoImportPath("context")
	errPkg     = protogen.GoImportPath("errors")
)

// generateAdapterFile generates a _adapter.pb.go file.
func generateAdapterFile(gen *protogen.Plugin, file *protogen.File, flagVar FlagVar) bool {
	requestPath := parseOneofPath(flagVar.RequestOneofPath)
	responsePath := parseOneofPath(flagVar.ResponseOneofPath)

	var reqOneOf, respOneOf *protogen.Oneof
	for _, msg := range file.Messages {
		msgName := string(msg.Desc.Name())
		if msgName == requestPath.MessageName {
			for _, oneof := range msg.Oneofs {
				if string(oneof.Desc.Name()) == requestPath.OneofName {
					reqOneOf = oneof
				}
			}
		} else if msgName == responsePath.MessageName {
			for _, oneof := range msg.Oneofs {
				if string(oneof.Desc.Name()) == responsePath.OneofName {
					respOneOf = oneof
				}
			}
		}
	}

	if reqOneOf == nil {
		return false
	}
	if respOneOf == nil {
		panic(fmt.Errorf("not found response path: %s, should be in the same file as the request", flagVar.ResponseOneofPath))
	}

	tmpl := &AdapterTemplate{
		ApiName:                flagVar.ApiName,
		PackageName:            "",
		UnionRequestType:       requestPath.MessageName,
		UnionResponseType:      responsePath.MessageName,
		UnionRequestBodyField:  reqOneOf.GoName,
		UnionResponseBodyField: respOneOf.GoName,
	}
	for i := 0; i < reqOneOf.Desc.Fields().Len(); i++ {
		reqBodyFieldDesc := reqOneOf.Desc.Fields().Get(i)
		reqNum := reqBodyFieldDesc.Number()
		reqName := string(reqBodyFieldDesc.Message().Name())
		respBodyFieldDesc := respOneOf.Desc.Fields().ByNumber(reqNum)
		if respBodyFieldDesc == nil {
			panic(fmt.Errorf("not found response message by number: %d", reqNum))
		}
		respName := string(respBodyFieldDesc.Message().Name())

		hf := HandlerFunc{}
		hf.RequestType = reqName
		hf.ResponseType = respName
		hf.RequestOneofField = reqOneOf.Fields[i].GoName
		hf.ResponseOneofField = respOneOf.Fields[i].GoName

		hf.RequestOneofType = requestPath.MessageName + "_" + hf.RequestOneofField
		hf.ResponseOneofType = responsePath.MessageName + "_" + hf.ResponseOneofField
		hf.Method = strings.TrimSuffix(hf.RequestOneofField, "Request")

		tmpl.HandlerFuncList = append(tmpl.HandlerFuncList, hf)
	}
	if os.Getenv("DEBUG") == "1" {
		println(fmt.Sprintf("%+v", tmpl))
	}

	content, err := tmpl.execute()
	if err != nil {
		panic(err)
	}

	fileNameTail := "_api_adapter.pb.go"
	if strings.HasSuffix(file.GeneratedFilenamePrefix, "api") {
		fileNameTail = "_adapter.pb.go"
	}
	filename := file.GeneratedFilenamePrefix + fileNameTail
	g := gen.NewGeneratedFile(filename, file.GoImportPath)
	g.P("// Code generated by github.com/panjiang/protoc-gen-go-oneof-api-adapter. DO NOT EDIT.")
	g.P()
	g.P("package ", file.GoPackageName)
	g.P()
	g.P("// This is a compile-time assertion to import dependent packages.")
	g.P("// ", contextPkg.Ident(""))
	g.P("// ", errPkg.Ident(""))
	g.P()
	g.P(content)
	return true
}
